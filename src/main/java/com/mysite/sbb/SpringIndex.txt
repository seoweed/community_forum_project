0. 데이터 베이스와 연결 설정을 위해 application.properties 파일에다 설정 정보들을 적는다.

1. 처음 시작으로는 데이터 베이스와 연계하는 엔티티를 만든다.
(question, answer class 생성)

2. 엔티티만으로는 데이터베이스에 데이터를 저장하거나 조회 할 수 없다. 데이터 처리를 위해서는 실제 데이터베이스와 연동하는 JPA 리포지터리가 필요하다.
리포지터리는 엔티티에 의해 생성된 데이터베이스 테이블에 접근하는 메서드들(예: findAll, save 등)을 사용하기 위한 인터페이스이다.
데이터 처리를 위해서는 테이블에 어떤 값을 넣거나 값을 조회하는 등의 CRUD(Create, Read, Update, Delete)가 필요하다.
이 때 이러한 CRUD를 어떻게 처리할지 정의하는 계층이 바로 리포지터리이다.
가장 핵심은 JpaRepository 인터페이스를 상속받는 인터페이스를 만드는 것이다.(제네릭 사용)
리포지토리 인터페이스를 만든 후 테스트 코드를 만들어서 crud 기능이 잘 동작 하는지 확인 해본다.
테스트 코드는 JUnit을 사용 한다. JUnit은 테스트코드를 작성하고 작성한 테스트코드를 실행하기 위해 사용하는 자바의 테스트 프레임워크이다.
필요한 시점에 데이터를 가져오는 방식을 Lazy 방식이라고 한다. 이와 반대로 q 객체를 조회할때 답변 리스트를 모두 가져오는 방식은 Eager 방식이라고 한다.
@OneToMany, @ManyToOne 애너테이션의 옵션으로 fetch=FetchType.LAZY 또는 fetch=FetchType.EAGER 처럼 가져오는 방식을 설정할 수 있다.

3. controller 를 만들어서 웹과 매핑해준다. @responseBody 어노테이션을 사용하여 웹에 바로 문자열을 return 해준다.
하지만 바로 웹으로 문자를 출력하는 방식은 거의 사용하지 않는다. 일반적으로 많이 사용하는 방식은 템플릿 방식이다.  템플릿은 자바 코드를 삽입할 수 있는 HTML 형식의 파일이다.
여기서는 타임리프를 사용한다. resources/templates/example.html 경로에 html 파일을 넣어두고 controller 에서 return 값을 파일명으로 설정

@@ 스프링의 의존성 주입(Dependency Injection) 방식 3가지
@Autowired 속성 - 속성에 @Autowired 애너테이션을 적용하여 객체를 주입하는 방식
생성자 - 생성자를 작성하여 객체를 주입하는 방식 (권장하는 방식)
Setter - Setter 메서드를 작성하여 객체를 주입하는 방식 (메서드에 @Autowired 애너테이션 적용이 필요하다.)
테스트코드(SbbApplicationTests.java)에서는 속성에 @Autowired 애너테이션을 사용하여 객체를 주입했다.

@@ Model model 객체와 view 에서 사용
< Controller에서 사용자에게 응답할 View를 생성할 때 Model을 이용하여 View에 데이터를 전달하는 방법 >
model.addAttribute(String name, Object value); String name 부분에는 view 에서 작성할 이름을 정해주는 것임 {name}
value 부분에는 실제로 들어갈 데이터 값을 넣어준다. 사용할때는 view 에서 {name} 을 사용한다.
Model 객체는 자바 클래스와 템플릿 간의 연결고리 역할을 한다. Model 객체에 값을 담아두면 템플릿에서 그 값을 사용할 수 있다.
Model 객체는 따로 생성할 필요없이 컨트롤러 메서드의 매개변수로 지정하기만 하면 스프링부트가 자동으로 Model 객체를 생성한다.

4. service class 를 만든다.
이전 단계에서 질문 목록을 만들었다. 이제 질문 목록의 제목 링크를 누르면 질문 상세 화면이 보이게 할 것이다.
하지만 기능을 추가하기 전에 잠시 생각할 것이 있다. 우리는 QuestionController에서 QuestionRepository를 직접 사용하여
질문 목록 데이터를 조회했다. 하지만 대부분의 규모있는 스프링부트 프로젝트는 컨트롤러에서 리포지터리를 직접 호출하지 않고
중간에 서비스(Service)를 두어 데이터를 처리한다. 서비스는 스프링에서 데이터 처리를 위해 작성하는 클래스이다.
서비스가 필요한 이유 1번 : 모듈화(컨트롤러에서 리포지토리를 직접 생성하는 경우에 컨트롤러가 많아지면 하나하나 다 직접 생성을 해줘야 한다.)
2번 : 보안(컨트롤러는 리포지터리 없이 서비스를 통해서만 데이터베이스에 접근하도록 구현하는 것이 보안상 안전하다.)
3번 : 엔티티 객체와 DTO 객체의 변환
우리가 작성한 Question, Answer 클래스는 엔티티(Entity) 클래스이다. 엔티티 클래스는 데이터베이스와 직접 맞닿아 있는 클래스이기 때문에
컨트롤러나 타임리프 같은 템플릿 엔진에 전달하여 사용하는 것은 좋지 않다. 컨트롤러나 타임리프에서 사용하는 데이터 객체는 속성을 변경하여
비즈니스적인 요구를 처리해야 하는 경우가 많은데 엔티티를 직접 사용하여 속성을 변경한다면 테이블 컬럼이 변경되어 엉망이 될수도 있기 때문이다.

엔티티를 DTO 객체로 변환해야 하는 이유
이러한 이유로 Question, Answer 같은 엔티티 클래스는 컨트롤러에서 사용할수 없게끔 설계하는 것이 좋다.
그러기 위해서는 Question, Answer 대신 사용할 DTO(Data Transfer Object) 클래스가 필요하다.
그리고 Question, Answer 등의 엔티티 객체를 DTO 객체로 변환하는 작업도 필요하다.
그러면 엔티티 객체를 DTO 객체로 변환하는 일은 어디서 처리해야 할까? 그렇다. 바로 서비스이다.
서비스는 컨트롤러와 리포지터리의 중간자적인 입장에서 엔티티 객체와 DTO 객체를 서로 변환하여 양방향에 전달하는 역할을 한다.

앞으로 작성할 컨트롤러들도 리포지터리를 직접 사용하지 않고 Controller -> Service -> Repository 구조로 데이터를 처리할 것이다.

